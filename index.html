<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>消消乐</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0f172a">
<style>
html,body{margin:0;height:100%;background:#0f172a;color:#fff;font-family:system-ui}
#game{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%}
canvas{touch-action:none}
#top{margin-bottom:10px}
</style>
</head>
<body>
<div id="game">
  <div id="top">分数：<span id="score">0</span></div>
  <canvas id="c"></canvas>
</div>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

const COLS=8, ROWS=8;
const SIZE=48;
const TYPES=6;
let board=[];
let score=0;
let animating=false;

function resize(){
  const scale=Math.min(innerWidth/(COLS*SIZE), (innerHeight-80)/(ROWS*SIZE));
  canvas.width=COLS*SIZE*scale;
  canvas.height=ROWS*SIZE*scale;
  ctx.setTransform(scale,0,0,scale,0,0);
}
resize(); addEventListener('resize',resize);

function randType(){ return Math.floor(Math.random()*TYPES); }

function init(){
  board=[];
  for(let y=0;y<ROWS;y++){
    const row=[];
    for(let x=0;x<COLS;x++){
      let t;
      do{
        t=randType();
      }while(
        (x>=2 && row[x-1]===t && row[x-2]===t) ||
        (y>=2 && board[y-1][x]===t && board[y-2][x]===t)
      );
      row.push(t);
    }
    board.push(row);
  }
}
init();

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t=board[y][x];
      if(t==null) continue;
      ctx.fillStyle=[
        "#f43f5e","#22c55e","#38bdf8",
        "#facc15","#a78bfa","#fb923c"
      ][t];
      ctx.fillRect(x*SIZE,y*SIZE,SIZE-4,SIZE-4);
    }
  }
}

function findMatches(){
  const marks=new Set();
  // 横
  for(let y=0;y<ROWS;y++){
    let cnt=1;
    for(let x=1;x<=COLS;x++){
      if(x<COLS && board[y][x]===board[y][x-1] && board[y][x]!=null){
        cnt++;
      }else{
        if(cnt>=3){
          for(let k=0;k<cnt;k++) marks.add(`${y},${x-1-k}`);
        }
        cnt=1;
      }
    }
  }
  // 竖
  for(let x=0;x<COLS;x++){
    let cnt=1;
    for(let y=1;y<=ROWS;y++){
      if(y<ROWS && board[y][x]===board[y-1][x] && board[y][x]!=null){
        cnt++;
      }else{
        if(cnt>=3){
          for(let k=0;k<cnt;k++) marks.add(`${y-1-k},${x}`);
        }
        cnt=1;
      }
    }
  }
  return [...marks].map(s=>s.split(',').map(Number));
}

async function clearMatches(){
  let combo=0;
  while(true){
    const matches=findMatches();
    if(!matches.length) break;
    combo++;
    matches.forEach(([y,x])=>board[y][x]=null);
    score+=matches.length*10*combo;
    scoreEl.textContent=score;
    await drop();
  }
}

async function drop(){
  for(let x=0;x<COLS;x++){
    let stack=[];
    for(let y=ROWS-1;y>=0;y--){
      if(board[y][x]!=null) stack.push(board[y][x]);
    }
    for(let y=ROWS-1;y>=0;y--){
      board[y][x]=stack.shift() ?? randType();
    }
  }
  await sleep(150);
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

let sx,sy,sel=null;

canvas.onpointerdown=e=>{
  if(animating) return;
  const rect=canvas.getBoundingClientRect();
  sx=Math.floor((e.clientX-rect.left)/(rect.width/COLS));
  sy=Math.floor((e.clientY-rect.top)/(rect.height/ROWS));
  sel={x:sx,y:sy};
};

canvas.onpointerup=e=>{
  if(!sel || animating) return;
  const rect=canvas.getBoundingClientRect();
  const ex=Math.floor((e.clientX-rect.left)/(rect.width/COLS));
  const ey=Math.floor((e.clientY-rect.top)/(rect.height/ROWS));
  const dx=Math.abs(ex-sel.x), dy=Math.abs(ey-sel.y);
  if(dx+dy===1){
    swap(sel.x,sel.y,ex,ey);
  }
  sel=null;
};

async function swap(x1,y1,x2,y2){
  [board[y1][x1],board[y2][x2]]=[board[y2][x2],board[y1][x1]];
  if(!findMatches().length){
    [board[y1][x1],board[y2][x2]]=[board[y2][x2],board[y1][x1]];
    return;
  }
  animating=true;
  await clearMatches();
  animating=false;
}

function loop(){
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
